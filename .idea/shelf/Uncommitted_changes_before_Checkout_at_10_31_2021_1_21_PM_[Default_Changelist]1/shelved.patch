Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/DuckDetector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.subsystem;\r\n\r\nimport com.ftc11392.sequoia.subsystem.Subsystem;\r\nimport com.ftc11392.sequoia.util.Clock;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\nimport org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;\r\nimport org.opencv.core.Core;\r\nimport org.opencv.core.Mat;\r\nimport org.opencv.core.MatOfPoint;\r\nimport org.opencv.core.Point;\r\nimport org.opencv.core.Scalar;\r\nimport org.opencv.imgproc.Imgproc;\r\nimport org.openftc.easyopencv.OpenCvCamera;\r\nimport org.openftc.easyopencv.OpenCvCameraFactory;\r\nimport org.openftc.easyopencv.OpenCvCameraRotation;\r\nimport org.openftc.easyopencv.OpenCvPipeline;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class DuckDetector extends Subsystem {\r\n\r\n    protected OpenCvCamera camera;\r\n    protected Clock clock;\r\n\r\n    protected final int ROWS = 640;\r\n    protected final int COLS = 480;\r\n\r\n    protected static final Scalar RED = new Scalar(255, 0, 0);\r\n    protected static final Scalar GREEN = new Scalar(0, 255, 0);\r\n    protected static final Scalar BLUE = new Scalar(0, 0, 255);\r\n\r\n    //-------------------------------------------------------\r\n\r\n    protected static int valBottom = -1;\r\n    protected static int valTop = -1;\r\n\r\n    protected static int numOfRings;\r\n\r\n    protected static float rectHeight = 0.3f / 8f; //0.2f/8f;\r\n    protected static float rectWidth = 1.2f / 8f; //0.84f/8f;\r\n\r\n    protected static float offsetX = 3.5f / 8f;//changing this moves the two rects and the two circles left or right, range : (-2, 2) not inclusive\r\n    protected static float offsetY = 1.3f / 8f; // move down 0f/8f;//changing this moves the two rects and circles up or down, range: (-4, 4) not inclusive\r\n    //moves all rectangles right or left by amount. units are in ratio to monitor\r\n    protected static float[] bottomPos = {4f / 8f + offsetX, 2.6f / 8f + offsetY};//0 = col, 1 = row\r\n    protected static float[] topPos = {4f / 8f + offsetX, 2.2f / 8f + offsetY}; //0f/8f is the highest\r\n\r\n    @Override\r\n    public void initialize(HardwareMap hardwareMap) {\r\n        clock = new Clock();\r\n        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier(\"cameraMonitorViewId\", \"id\", hardwareMap.appContext.getPackageName());\r\n        camera = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, \"camera\"), cameraMonitorViewId);\r\n        camera.openCameraDevice();\r\n        camera.startStreaming(320, 240, OpenCvCameraRotation.UPRIGHT);\r\n\r\n        camera.setPipeline(new RingPipeline());\r\n    }\r\n\r\n    @Override\r\n    public void initPeriodic() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void start() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void runPeriodic() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n        camera.stopStreaming();\r\n    }\r\n\r\n    public int detectRings() { //returns 0, 1 or 4\r\n        int pos = -1;\r\n\r\n        if(valTop == -1 || valBottom == -1) {\r\n            return -1;\r\n        }\r\n\r\n        if (valTop > 100) pos = 4; //top is yellow enough\r\n        else if (valBottom > 100) pos = 1; //top is not yellow but bottom is yellow enough\r\n        else pos = 0;\r\n\r\n        telemetry.addData(\"Values \", valTop + \"   \" + valBottom);\r\n        telemetry.addData(\"pos \", pos);\r\n\r\n        numOfRings = pos;\r\n        return pos;\r\n    }\r\n\r\n    public int getDetectedRings(){\r\n        return numOfRings;\r\n    }\r\n\r\n    static class RingPipeline extends OpenCvPipeline {\r\n        enum Stage {//color difference. greyscale\r\n            detection,//includes outlines\r\n            THRESHOLD,//b&w\r\n            RAW_IMAGE,//displays raw view\r\n        }\r\n\r\n        private Stage stageToRenderToViewport = Stage.detection;\r\n        private Stage[] stages = Stage.values();\r\n\r\n        Mat yCbCrChan2Mat = new Mat(); //the popular JPEG image format\r\n        Mat thresholdMat = new Mat();\r\n        Mat all = new Mat();\r\n        List<MatOfPoint> contoursList = new ArrayList<>();\r\n\r\n        @Override\r\n        public void onViewportTapped() {\r\n            /*\r\n             * Note that this method is invoked from the UI thread\r\n             * so whatever we do here, we must do quickly.\r\n             */\r\n            int currentStageNum = stageToRenderToViewport.ordinal();\r\n            int nextStageNum = currentStageNum + 1;\r\n\r\n            if (nextStageNum >= stages.length) {\r\n                nextStageNum = 0;\r\n            }\r\n            stageToRenderToViewport = stages[nextStageNum];\r\n        }\r\n\r\n        @Override\r\n        public Mat processFrame(Mat input) {\r\n            contoursList.clear();\r\n\r\n            //color diff cb.\r\n            //lower cb = more blue = skystone = white\r\n            //higher cb = less blue = yellow stone = grey\r\n            Imgproc.cvtColor(input, yCbCrChan2Mat, Imgproc.COLOR_RGB2YCrCb);//converts rgb to ycrcb\r\n            Core.extractChannel(yCbCrChan2Mat, yCbCrChan2Mat, 2);//takes cb difference and stores\r\n\r\n            //b&w\r\n            Imgproc.threshold(yCbCrChan2Mat, thresholdMat, 110, 255, Imgproc.THRESH_BINARY_INV);\r\n\r\n            //outline/contour\r\n            Imgproc.findContours(thresholdMat, contoursList, new Mat(), Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);\r\n            yCbCrChan2Mat.copyTo(all);//copies mat object\r\n            //Imgproc.drawContours(all, contoursList, -1, new Scalar(255, 0, 0), 3, 8);//draws blue contours\r\n\r\n            //get values from frame\r\n            double[] pixBottom = thresholdMat.get((int) (input.rows() * bottomPos[1]), (int) (input.cols() * bottomPos[0]));//gets value at circle\r\n            valBottom = (int) pixBottom[0];\r\n\r\n            double[] pixTop = thresholdMat.get((int) (input.rows() * topPos[1]), (int) (input.cols() * topPos[0]));//gets value at circle\r\n            valTop = (int) pixTop[0];\r\n\r\n            //create two points\r\n            Point pointBottom = new Point((int) (input.cols() * bottomPos[0]), (int) (input.rows() * bottomPos[1]));\r\n            Point pointTop = new Point((int) (input.cols() * topPos[0]), (int) (input.rows() * topPos[1]));\r\n            //draw circles on those points\r\n            Imgproc.circle(all, pointBottom, 5, RED, 1);//draws circle\r\n            Imgproc.circle(all, pointTop, 5, RED, 1);//draws circle\r\n\r\n            //draw 2 rectangles\r\n            Imgproc.rectangle(//top\r\n                    all,\r\n                    new Point(\r\n                            input.cols() * (topPos[0] - rectWidth / 2),\r\n                            input.rows() * (topPos[1] - rectHeight)),\r\n                    new Point(\r\n                            input.cols() * (topPos[0] + rectWidth / 2),\r\n                            input.rows() * (topPos[1] + rectHeight)),\r\n                    GREEN, 2);\r\n            Imgproc.rectangle(//bottom\r\n                    all,\r\n                    new Point(\r\n                            input.cols() * (bottomPos[0] - rectWidth / 2),\r\n                            input.rows() * (bottomPos[1] - rectHeight / 2)),\r\n                    new Point(\r\n                            input.cols() * (bottomPos[0] + rectWidth / 2),\r\n                            input.rows() * (bottomPos[1] + rectHeight / 2)),\r\n                    GREEN, 2);\r\n\r\n            switch (stageToRenderToViewport) {\r\n                case THRESHOLD:\r\n                    return thresholdMat;\r\n                case detection:\r\n                    return all;\r\n                case RAW_IMAGE:\r\n                    return input;\r\n                default:\r\n                    return input;\r\n            }\r\n        }\r\n    }\r\n}
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/DuckDetector.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/DuckDetector.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/DuckDetector.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/DuckDetector.java	
@@ -36,7 +36,7 @@
     protected static int valBottom = -1;
     protected static int valTop = -1;
 
-    protected static int numOfRings;
+    protected static int positionOfDuck;
 
     protected static float rectHeight = 0.3f / 8f; //0.2f/8f;
     protected static float rectWidth = 1.2f / 8f; //0.84f/8f;
@@ -78,7 +78,7 @@
         camera.stopStreaming();
     }
 
-    public int detectRings() { //returns 0, 1 or 4
+    public int detectDucks() { //returns 0, 1 or 4
         int pos = -1;
 
         if(valTop == -1 || valBottom == -1) {
@@ -92,12 +92,12 @@
         telemetry.addData("Values ", valTop + "   " + valBottom);
         telemetry.addData("pos ", pos);
 
-        numOfRings = pos;
+        positionOfDuck = pos;
         return pos;
     }
 
-    public int getDetectedRings(){
-        return numOfRings;
+    public int getDetectedDucks(){
+        return positionOfDuck;
     }
 
     static class RingPipeline extends OpenCvPipeline {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumTeleOp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.util.Range;\r\n\r\n\r\n@TeleOp(name = \"MecanumDrive\", group = \"Quackology\")\r\npublic class MecanumTeleOp extends OpMode {\r\n\r\n\r\n    private DcMotorEx frontLeft, frontRight, backLeft, backRight, carouselMotor;\r\n    static final double INCREMENT = 0.01;     // amount to slew servo each CYCLE_MS cycle\r\n    static final int CYCLE_MS = 50;     // period of each cycle\r\n    static final double MAX_POS = 1.0;     // Maximum rotational position\r\n    static final double MIN_POS = 0.0;     // Minimum rotational position\r\n\r\n    // Define class members\r\n    Servo servo;\r\n    double position = (MAX_POS - MIN_POS) / 2; // Start at halfway position\r\n    boolean rampUp = true;\r\n\r\n\r\n    @Override\r\n\r\n\r\n    public void init() {\r\n        telemetry.addData(\"Status\", \"Initializing...\");\r\n\r\n\r\n        frontLeft = hardwareMap.get(DcMotorEx.class, \"frontLeft\");\r\n        frontRight = hardwareMap.get(DcMotorEx.class, \"frontRight\");\r\n        backLeft = hardwareMap.get(DcMotorEx.class, \"backLeft\");\r\n        backRight = hardwareMap.get(DcMotorEx.class, \"backRight\");\r\n\r\n\r\n        frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        backLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n\r\n\r\n        // Connect to servo (Assume PushBot Left Hand)\r\n        // Change the text in quotes to match any servo name on your robot.\r\n        servo = hardwareMap.get(Servo.class, \"left_hand\");\r\n\r\n        telemetry.addData(\"Status\", \"Initialized\");\r\n        telemetry.update();\r\n\r\n    }\r\n\r\n    @Override\r\n    public void loop() {\r\n        double drive = -gamepad1.left_stick_y;\r\n        double strafe = gamepad1.left_stick_x;\r\n        double turn = gamepad1.right_stick_x;\r\n        boolean spin = gamepad1.y;\r\n\r\n\r\n        double frontLeftPower = Range.clip(drive + strafe + turn, -1.0, 1.0);\r\n        double frontRightPower = Range.clip(drive - strafe - turn, -1.0, 1.0);\r\n        double backLeftPower = Range.clip(drive + strafe - turn, -1.0, 1.0);\r\n        double backRightPower = Range.clip(drive - strafe + turn, -1.0, 1.0);\r\n\r\n        frontLeft.setPower(frontLeftPower);\r\n        frontRight.setPower(frontRightPower);\r\n        backLeft.setPower(backLeftPower);\r\n        backRight.setPower(backRightPower);\r\n\r\n        while (spin == true) {\r\n            carouselMotor.setPower(1.0);\r\n        }\r\n\r\n        // slew the servo, according to the rampUp (direction) variable.\r\n        if (rampUp) {\r\n            // Keep stepping up until we hit the max value.\r\n            position += INCREMENT;\r\n            if (position >= MAX_POS) {\r\n                position = MAX_POS;\r\n                rampUp = !rampUp;   // Switch ramp direction\r\n            }\r\n        } else {\r\n            // Keep stepping down until we hit the min value.\r\n            position -= INCREMENT;\r\n            if (position <= MIN_POS) {\r\n                position = MIN_POS;\r\n                rampUp = !rampUp;  // Switch ramp direction\r\n            }\r\n        }\r\n\r\n        telemetry.addData(\"Motors\", \"frontLeft (%.2f), frontRight (%.2f), backLeft (%.2f), backRight(%.2f)\",\r\n                frontLeftPower, frontRightPower, backLeftPower, backRightPower);\r\n        telemetry.addData(\"Servo Position\", \"%5.2f\", position);\r\n        telemetry.update();\r\n\r\n        // Set the servo to the new position and pause;\r\n\r\n        servo.setPosition(position);\r\n\r\n    }\r\n\r\n}\r\n\r\n
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumTeleOp.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumTeleOp.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumTeleOp.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/MecanumTeleOp.java	
@@ -5,27 +5,26 @@
 import com.qualcomm.robotcore.hardware.DcMotorEx;
 import com.qualcomm.robotcore.hardware.DcMotorSimple;
 import com.qualcomm.robotcore.hardware.Servo;
-import com.qualcomm.robotcore.eventloop.opmode.Disabled;
-import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.util.Range;
 
+import org.firstinspires.ftc.teamcode.subsystem.LiftE;
 
-@TeleOp(name = "MecanumDrive", group = "Quackology")
+
+@TeleOp(name = "MecanumDriveE", group = "Quackology")
 public class MecanumTeleOp extends OpMode {
 
 
-    private DcMotorEx frontLeft, frontRight, backLeft, backRight, carouselMotor;
+    private DcMotorEx frontLeft, frontRight, backLeft, backRight, carousel;
+    private Servo clawServo, wristServo;
     static final double INCREMENT = 0.01;     // amount to slew servo each CYCLE_MS cycle
     static final int CYCLE_MS = 50;     // period of each cycle
     static final double MAX_POS = 1.0;     // Maximum rotational position
     static final double MIN_POS = 0.0;     // Minimum rotational position
 
-    // Define class members
-    Servo servo;
     double position = (MAX_POS - MIN_POS) / 2; // Start at halfway position
-    boolean rampUp = true;
-
-
+    double clawPosition = 0.5;
+    double wristPosition = 0.7;
+    LiftE lifte;
     @Override
 
 
@@ -37,7 +36,11 @@
         frontRight = hardwareMap.get(DcMotorEx.class, "frontRight");
         backLeft = hardwareMap.get(DcMotorEx.class, "backLeft");
         backRight = hardwareMap.get(DcMotorEx.class, "backRight");
-
+        carousel = hardwareMap.get(DcMotorEx.class, "carousel");
+        clawServo = hardwareMap.get(Servo.class, "clawservo");
+        wristServo = hardwareMap.get(Servo.class, "wristservo");
+        lifte = new LiftE(hardwareMap);
+        lifte.init();
 
         frontLeft.setDirection(DcMotorSimple.Direction.REVERSE);
         backLeft.setDirection(DcMotorSimple.Direction.REVERSE);
@@ -45,7 +48,7 @@
 
         // Connect to servo (Assume PushBot Left Hand)
         // Change the text in quotes to match any servo name on your robot.
-        servo = hardwareMap.get(Servo.class, "left_hand");
+        //servo = hardwareMap.get(Servo.class, "carousel");
 
         telemetry.addData("Status", "Initialized");
         telemetry.update();
@@ -55,50 +58,61 @@
     @Override
     public void loop() {
         double drive = -gamepad1.left_stick_y;
-        double strafe = gamepad1.left_stick_x;
+        double strafe = -gamepad1.left_stick_x;
         double turn = gamepad1.right_stick_x;
         boolean spin = gamepad1.y;
 
 
         double frontLeftPower = Range.clip(drive + strafe + turn, -1.0, 1.0);
         double frontRightPower = Range.clip(drive - strafe - turn, -1.0, 1.0);
-        double backLeftPower = Range.clip(drive + strafe - turn, -1.0, 1.0);
-        double backRightPower = Range.clip(drive - strafe + turn, -1.0, 1.0);
+        double backLeftPower = Range.clip(drive - strafe + turn, -1.0, 1.0);
+        double backRightPower = Range.clip(drive + strafe - turn, -1.0, 1.0);
 
         frontLeft.setPower(frontLeftPower);
         frontRight.setPower(frontRightPower);
         backLeft.setPower(backLeftPower);
         backRight.setPower(backRightPower);
 
+        if(gamepad1.x){
+            carousel.setPower(0.5);
+        }
+        if(gamepad1.a){
+            carousel.setPower(0);
+        }
         while (spin == true) {
-            carouselMotor.setPower(1.0);
+            carousel.setPower(1.0);
+        }
+
+        if(gamepad2.a){
+            clawPosition = 1.0;
         }
 
-        // slew the servo, according to the rampUp (direction) variable.
-        if (rampUp) {
-            // Keep stepping up until we hit the max value.
-            position += INCREMENT;
-            if (position >= MAX_POS) {
-                position = MAX_POS;
-                rampUp = !rampUp;   // Switch ramp direction
-            }
-        } else {
-            // Keep stepping down until we hit the min value.
-            position -= INCREMENT;
-            if (position <= MIN_POS) {
-                position = MIN_POS;
-                rampUp = !rampUp;  // Switch ramp direction
-            }
+        if(gamepad2.y){
+            clawPosition = 0.0;
+        }
+        if(gamepad2.b){
+            wristPosition = 0.9;
+        }
+        if(gamepad2.x){
+            wristPosition = 0.7;
         }
+        if(gamepad1.dpad_up){
+            lifte.moveByInchTele(2,0.5);
+        }
+        if(gamepad1.dpad_down){
+            lifte.moveByInchTele(-2,0.5);
+        }
 
         telemetry.addData("Motors", "frontLeft (%.2f), frontRight (%.2f), backLeft (%.2f), backRight(%.2f)",
                 frontLeftPower, frontRightPower, backLeftPower, backRightPower);
-        telemetry.addData("Servo Position", "%5.2f", position);
+        telemetry.addData("Claw Position", "%5.2f", clawPosition);
+        telemetry.addData("Wrist Position", "%5.2f", wristPosition);
+        telemetry.addData("Lift Position", lifte.liftMotor.getCurrentPosition());
+        telemetry.addData("Lift Position", lifte.targetPos);
         telemetry.update();
 
-        // Set the servo to the new position and pause;
-
-        servo.setPosition(position);
+        clawServo.setPosition(clawPosition);
+        wristServo.setPosition(wristPosition);
 
     }
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/LiftE.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorEx;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\n\r\n//import org.firstinspires.ftc.teamcode.teamLib.utils.TeleBug;\r\n\r\npublic class LiftE {\r\n    public DcMotorEx liftMotor; //for bettrn PID of run to position\r\n\r\n    protected HardwareMap hwMap;\r\n    //protected TeleBug teleBug;\r\n\r\n    private static final double TICKS_PER_MOTOR_REV     = 1120; //Andymark motor on rev 20 gear box\r\n    private static final double WHEEL_DIAMETER_INCHES   = 1.5;     // For figuring circumference\r\n    public static final double TICKS_PER_INCH = TICKS_PER_MOTOR_REV / (WHEEL_DIAMETER_INCHES * Math.PI);\r\n\r\n    private static final int POSITIONING_TOLERANCE = 30; //The amount of ticks the DriveByInch method should be allowed to deviate by\r\n    public static int BOTTOM = 0; //positon at the bottom\r\n    private static final int TOP = 6000; //positon at the top\r\n\r\n    public LiftE (HardwareMap hwMap){\r\n        this.hwMap = hwMap;\r\n    }\r\n\r\n    public void init() {\r\n        liftMotor = hwMap.get(DcMotorEx.class, \"lift\");\r\n        liftMotor.setTargetPositionTolerance(POSITIONING_TOLERANCE);\r\n    }\r\n\r\n    public void moveByInch(double inches, double power){\r\n        int targetPos = (int)(inches * TICKS_PER_INCH);\r\n\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        liftMotor.setPower(power);\r\n\r\n        liftMotor.setTargetPosition(liftMotor.getCurrentPosition() + targetPos);\r\n\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n        while (liftMotor.isBusy() ){}\r\n        liftMotor.setPower(0);\r\n    }\r\n\r\n    public void moveByInchTele(double inches, double power){\r\n        int targetPos = (int)(inches * TICKS_PER_INCH);\r\n\r\n//        liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        liftMotor.setPower(power);\r\n\r\n        //prevent going past 0?\r\n        if (liftMotor.getCurrentPosition() + targetPos < BOTTOM-1)\r\n            liftMotor.setTargetPosition(BOTTOM-1);\r\n        else\r\n            liftMotor.setTargetPosition(liftMotor.getCurrentPosition() + targetPos);\r\n\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n    }\r\n    public void moveByInchTeleBeyond(double inches, double power){\r\n        int targetPos = (int)(inches * TICKS_PER_INCH);\r\n\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        liftMotor.setPower(power);\r\n\r\n        //prevent going past 0?\r\n        liftMotor.setTargetPosition(liftMotor.getCurrentPosition() + targetPos);\r\n\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n    }\r\n\r\n    public void stop() {liftMotor.setPower(0.0);}\r\n\r\n    public int positionTicks() {return liftMotor.getCurrentPosition(); }\r\n\r\n    public void firstPos() {\r\n        moveByInch(7, 1.);\r\n    }\r\n    public void bottom() { //move to the bottome position\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n\r\n        liftMotor.setPower(-1.0);\r\n\r\n        liftMotor.setTargetPosition(BOTTOM-1);\r\n        liftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);\r\n    }\r\n\r\n    public void release() { //move to the bottome position\r\n        moveByInch(-9, 1.);\r\n    }\r\n\r\n    public void pull() {\r\n        moveByInch(9, 1.);\r\n    }\r\n}
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/LiftE.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/LiftE.java
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/LiftE.java	
+++ b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/LiftE.java	
@@ -1,4 +1,4 @@
-package org.firstinspires.ftc.teamcode;
+package org.firstinspires.ftc.teamcode.subsystem;
 
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.DcMotorEx;
@@ -8,7 +8,7 @@
 
 public class LiftE {
     public DcMotorEx liftMotor; //for bettrn PID of run to position
-
+    public int targetPos;
     protected HardwareMap hwMap;
     //protected TeleBug teleBug;
 
@@ -27,10 +27,11 @@
     public void init() {
         liftMotor = hwMap.get(DcMotorEx.class, "lift");
         liftMotor.setTargetPositionTolerance(POSITIONING_TOLERANCE);
+        liftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
     }
 
     public void moveByInch(double inches, double power){
-        int targetPos = (int)(inches * TICKS_PER_INCH);
+        targetPos = (int)(inches * TICKS_PER_INCH);
 
         liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
 
@@ -44,7 +45,7 @@
     }
 
     public void moveByInchTele(double inches, double power){
-        int targetPos = (int)(inches * TICKS_PER_INCH);
+        targetPos = (int)(inches * TICKS_PER_INCH);
 
 //        liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/task/LiftTask.java
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/task/LiftTask.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/task/LiftTask.java
deleted file mode 100644
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/task/LiftTask.java	
+++ /dev/null	
@@ -1,2 +0,0 @@
-package org.firstinspires.ftc.teamcode.task;public class LiftTask {
-}
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/Lift.java
===================================================================
diff --git a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/Lift.java b/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/Lift.java
deleted file mode 100644
--- a/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/subsystem/Lift.java	
+++ /dev/null	
@@ -1,2 +0,0 @@
-package org.firstinspires.ftc.teamcode.subsystem;public class Lift {
-}
